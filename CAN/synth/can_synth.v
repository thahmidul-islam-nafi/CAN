/* Generated by Yosys 0.9 (git sha1 1979e0b) */

(* src = "can_controller.v:1" *)
module can_controller(clk, reset, data_in, send, can_in, can_out, data_out, valid, busy);
  (* src = "can_controller.v:10" *)
  output busy;
  (* src = "can_controller.v:6" *)
  input can_in;
  (* src = "can_controller.v:7" *)
  output can_out;
  (* src = "can_controller.v:2" *)
  input clk;
  (* src = "can_controller.v:4" *)
  input [7:0] data_in;
  (* src = "can_controller.v:8" *)
  output [7:0] data_out;
  (* src = "can_controller.v:3" *)
  input reset;
  (* src = "can_controller.v:13" *)
  wire rx_valid;
  (* src = "can_controller.v:5" *)
  input send;
  (* src = "can_controller.v:12" *)
  wire tx_busy;
  (* src = "can_controller.v:9" *)
  output valid;
  (* module_not_derived = 32'd1 *)
  (* src = "can_controller.v:24" *)
  can_rx receiver (
    .can_in(can_in),
    .clk(clk),
    .data_out(data_out),
    .reset(reset),
    .valid(rx_valid)
  );
  (* module_not_derived = 32'd1 *)
  (* src = "can_controller.v:15" *)
  can_tx transmitter (
    .busy(tx_busy),
    .can_out(can_out),
    .clk(clk),
    .data_in(data_in),
    .reset(reset),
    .send(send)
  );
  assign busy = tx_busy;
  assign valid = rx_valid;
endmodule

(* src = "can_rx.v:1" *)
module can_rx(clk, reset, can_in, data_out, valid);
  (* src = "can_rx.v:9" *)
  wire [7:0] _00_;
  (* src = "can_rx.v:4" *)
  input can_in;
  (* src = "can_rx.v:2" *)
  input clk;
  (* src = "can_rx.v:5" *)
  output [7:0] data_out;
  reg [7:0] data_out;
  (* src = "can_rx.v:3" *)
  input reset;
  (* src = "can_rx.v:6" *)
  output valid;
  reg valid;
  assign _00_[0] = can_in | data_out[0];
  assign _00_[1] = can_in ? data_out[0] : data_out[1];
  assign _00_[2] = can_in ? data_out[1] : data_out[2];
  assign _00_[3] = can_in ? data_out[2] : data_out[3];
  assign _00_[4] = can_in ? data_out[3] : data_out[4];
  assign _00_[5] = can_in ? data_out[4] : data_out[5];
  assign _00_[6] = can_in ? data_out[5] : data_out[6];
  assign _00_[7] = can_in ? data_out[6] : data_out[7];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[0] <= 0;
    else
      data_out[0] <= _00_[0];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[1] <= 0;
    else
      data_out[1] <= _00_[1];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[2] <= 0;
    else
      data_out[2] <= _00_[2];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[3] <= 0;
    else
      data_out[3] <= _00_[3];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[4] <= 0;
    else
      data_out[4] <= _00_[4];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[5] <= 0;
    else
      data_out[5] <= _00_[5];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[6] <= 0;
    else
      data_out[6] <= _00_[6];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      data_out[7] <= 0;
    else
      data_out[7] <= _00_[7];
  (* src = "can_rx.v:9" *)
  always @(posedge clk or posedge reset)
    if (reset)
      valid <= 0;
    else
      valid <= can_in;
endmodule

(* top =  1  *)
(* src = "can_top.v:1" *)
module can_top(clk, reset, data_in, send, can_in, can_out, data_out, valid, busy);
  (* src = "can_top.v:10" *)
  output busy;
  (* src = "can_top.v:6" *)
  input can_in;
  (* src = "can_top.v:7" *)
  output can_out;
  (* src = "can_top.v:2" *)
  input clk;
  (* src = "can_top.v:4" *)
  input [7:0] data_in;
  (* src = "can_top.v:8" *)
  output [7:0] data_out;
  (* src = "can_top.v:3" *)
  input reset;
  (* src = "can_top.v:5" *)
  input send;
  (* src = "can_top.v:9" *)
  output valid;
  (* module_not_derived = 32'd1 *)
  (* src = "can_top.v:12" *)
  can_controller controller (
    .busy(busy),
    .can_in(can_in),
    .can_out(can_out),
    .clk(clk),
    .data_in(data_in),
    .data_out(data_out),
    .reset(reset),
    .send(send),
    .valid(valid)
  );
endmodule

(* src = "can_tx.v:1" *)
module can_tx(clk, reset, data_in, send, can_out, busy);
  (* src = "can_tx.v:10" *)
  wire _0_;
  (* src = "can_tx.v:7" *)
  output busy;
  reg busy;
  (* src = "can_tx.v:6" *)
  output can_out;
  reg can_out;
  (* src = "can_tx.v:2" *)
  input clk;
  (* src = "can_tx.v:4" *)
  input [7:0] data_in;
  (* src = "can_tx.v:3" *)
  input reset;
  (* src = "can_tx.v:5" *)
  input send;
  assign _0_ = send ^ can_out;
  (* src = "can_tx.v:10" *)
  always @(posedge clk or posedge reset)
    if (reset)
      can_out <= 1;
    else
      can_out <= _0_;
  (* src = "can_tx.v:10" *)
  always @(posedge clk or posedge reset)
    if (reset)
      busy <= 0;
    else
      busy <= send;
endmodule
